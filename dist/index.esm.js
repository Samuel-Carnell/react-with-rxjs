import{useContext as e,useRef as r,useEffect as n,useState as t,useLayoutEffect as o,useCallback as s}from"react";import{Subject as u,isObservable as i,BehaviorSubject as a,connectable as c,ReplaySubject as b}from"rxjs";import{startWith as f,scan as l,distinctUntilChanged as v}from"rxjs/operators";function p(r){if(!(e=>"object"==typeof e&&null!=e&&"Consumer"in e&&"Provider"in e)(r))throw new TypeError(`${r} is not a React Context. For argument context in useContextObservable`);return E(e(r))}function m(e,r,n){r.length!==e.length&&function(e,...r){"development"===process.env.NODE_ENV&&console.error(e,r)}("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",n,`[${e.join(", ")}]`,`[${r.join(", ")}]`);for(let n=0;n<e.length&&n<r.length;n++)if(!Object.is(e[n],r[n]))return!0;return!1}function O(e,t="useHasInputChanged"){const o=r(e),s=m(o.current,e,t);return n((()=>{o.current=e})),s}function w(e,t,o="useFactory"){const s=r(void 0),u=O(t,o),i=void 0===s.current||u?e():s.current;return n((()=>{s.current=i})),i}function y(){const[e,r]=t(void 0);if(void 0!==e)throw e;return r}function d(){const e=w((()=>new u),[],"useEventObservable");o((()=>()=>e.complete()),[e]);const r=s((r=>e.next(r)),[e]);return[w((()=>e.asObservable()),[],"useEventObservable"),r]}function g(e){return"function"==typeof e}function h(e,r=[]){if(!g(e))throw new TypeError(`${e} is not a function. For argument observableFactory in useObservable`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useObservable`);const n=w(e,r,"useObservable");if(!i(n))throw new TypeError(`${n} is not an Observable. For return value of argument observableFactory in useObservable`);return n}function E(e){const r=w((()=>new a(e)),[],"useObservableOf"),t=O([e],"useObservableOf");return n((()=>{t&&r.next(e)})),w((()=>r.asObservable()),[r],"useObservableOf")}function $(e,r){if(!g(e))throw new TypeError(`${e} is not a function. For argument subscriptionFactory in useSubscription`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useSubscription`);o((()=>{const r=e();return()=>{r.closed||r.unsubscribe()}}),r)}function F(e){const r=w((()=>new u),[],"useStateObservable");o((()=>()=>r.complete()),[]);const n=s((e=>{const n=e;r.next(n)}),[r]),t=w((()=>function(e,r){const n=g(r)?r():r,t=e.pipe(f(n),l(((e,r)=>g(r)?r(e):r)),v(Object.is));return c(t,{connector:()=>new b(1),resetOnDisconnect:!1})}(r,e)),[r],"useStateObservable");return $((()=>t.connect()),[t]),[t,n]}function x(e){if(!i(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useIsComplete`);const r=y(),[n,s]=t(!1),u=O([e],"useIsComplete");return o((()=>{u&&s(!1)}),[u]),$((()=>e.subscribe({complete(){s(!0)},error(e){r(e)}})),[e]),n}function T(e){if(!i(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useLatestValue`);const r=y(),[n,o]=t((()=>function(e){return"getValue"in e}(e)?e.getValue():void 0));return $((()=>e.subscribe({next(e){o((()=>e))},error(e){r(e)}})),[e]),n}export{p as useContext$,p as useContextObservable,d as useEvent$,d as useEventObservable,x as useIsComplete,T as useLatestValue,h as useObservable,E as useObservableOf,F as useState$,F as useStateObservable,$ as useSubscription};
//# sourceMappingURL=index.esm.js.map
