import{useContext as e,useRef as r,useEffect as n,useState as t,useLayoutEffect as o,useCallback as s}from"react";import{Subject as u,isObservable as i,BehaviorSubject as a,connectable as c,ReplaySubject as b}from"rxjs";import{startWith as f,scan as l,distinctUntilChanged as v}from"rxjs/operators";function p(r){if(!(e=>"object"==typeof e&&null!=e&&"Consumer"in e&&"Provider"in e)(r))throw new TypeError(`${r} is not a React Context. For argument context in useContextObservable`);return $(e(r))}function m(e){return"function"==typeof e}function O(e,r,n){r.length!==e.length&&function(e,...r){"development"===process.env.NODE_ENV&&console.error(e,r)}("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",n,`[${e.join(", ")}]`,`[${r.join(", ")}]`);for(let n=0;n<e.length&&n<r.length;n++)if(!Object.is(e[n],r[n]))return!0;return!1}function w(e,t="useHasInputChanged"){const o=r(e),s=O(o.current,e,t);return n((()=>{o.current=e})),s}function y(e,t,o="useFactory"){const s=r(void 0),u=w(t,o),i=void 0===s.current||u?e():s.current;return n((()=>{s.current=i})),i}function d(){const[e,r]=t(void 0);if(void 0!==e)throw e;return r}function g(e,r){o((()=>{const r=e();return()=>{r.closed||r.unsubscribe()}}),r)}function h(){const e=y((()=>new u),[],"useEventObservable");o((()=>()=>e.complete()),[e]);const r=s((r=>e.next(r)),[e]);return[y((()=>e.asObservable()),[],"useEventObservable"),r]}function E(e,r=[]){if(!m(e))throw new TypeError(`${e} is not a function. For argument observableFactory in useObservable`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useObservable`);const n=y(e,r,"useObservable");if(!i(n))throw new TypeError(`${n} is not an Observable. For return value of argument observableFactory in useObservable`);return n}function $(e){const r=y((()=>new a(e)),[],"useObservableOf"),t=w([e],"useObservableOf");return n((()=>{t&&r.next(e)})),y((()=>r.asObservable()),[r],"useObservableOf")}function F(e,r){if(!m(e))throw new TypeError(`${e} is not a function. For argument subscriptionFactory in useSubscription`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useSubscription`);g(e,r)}function x(e){const r=y((()=>new u),[],"useStateObservable");o((()=>()=>r.complete()),[]);const n=s((e=>{const n=e;r.next(n)}),[r]),t=y((()=>function(e,r){const n=m(r)?r():r,t=e.pipe(f(n),l(((e,r)=>m(r)?r(e):r)),v(Object.is));return c(t,{connector:()=>new b(1),resetOnDisconnect:!1})}(r,e)),[r],"useStateObservable");return F((()=>t.connect()),[t]),[t,n]}function T(e){if(!i(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useIsComplete`);const r=d(),[n,s]=t(!1),u=w([e],"useIsComplete");return o((()=>{u&&s(!1)}),[u]),g((()=>e.subscribe({complete(){s(!0)},error(e){r(e)}})),[e]),n}function j(e){if(!i(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useLatestValue`);const r=d(),[n,o]=t((()=>function(e){return"getValue"in e}(e)?e.getValue():void 0));return g((()=>e.subscribe({next(e){o((()=>e))},error(e){r(e)}})),[e]),n}export{p as useContext$,p as useContextObservable,h as useEvent$,h as useEventObservable,T as useIsComplete,j as useLatestValue,E as useObservable,$ as useObservableOf,x as useState$,x as useStateObservable,F as useSubscription};
//# sourceMappingURL=index.esm.js.map
