import{useRef as e,useEffect as r,useState as n,useLayoutEffect as t,useCallback as o}from"react";import{Subject as s,isObservable as u,BehaviorSubject as i,connectable as c,ReplaySubject as a}from"rxjs";import{startWith as b,scan as f,distinctUntilChanged as l}from"rxjs/operators";function v(e,r,n){r.length!==e.length&&function(e,...r){"development"===process.env.NODE_ENV&&console.error(e,r)}("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",n,`[${e.join(", ")}]`,`[${r.join(", ")}]`);for(let n=0;n<e.length&&n<r.length;n++)if(!Object.is(e[n],r[n]))return!0;return!1}function p(n,t="useHasInputChanged"){const o=e(n),s=v(o.current,n,t);return r((()=>{o.current=n})),s}function m(n,t,o="useFactory"){const s=e(void 0),u=p(t,o),i=void 0===s.current||u?n():s.current;return r((()=>{s.current=i})),i}function O(){const e=m((()=>new s),[],"useEventObservable");t((()=>()=>e.complete()),[e]);const r=o((r=>e.next(r)),[e]);return[m((()=>e.asObservable()),[],"useEventObservable"),r]}function w(e){return"function"==typeof e}function y(e,r=[]){if(!w(e))throw new TypeError(`${e} is not a function. For argument observableFactory in useObservable`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useObservable`);const n=m(e,r,"useObservable");if(!u(n))throw new TypeError(`${n} is not an Observable. For return value of argument observableFactory in useObservable`);return n}function d(e){const n=m((()=>new i(e)),[],"useObservableOf"),t=p([e],"useObservableOf");return r((()=>{t&&n.next(e)})),m((()=>n.asObservable()),[n],"useObservableOf")}function h(e,r){if(!w(e))throw new TypeError(`${e} is not a function. For argument subscriptionFactory in useSubscription`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useSubscription`);t((()=>{const r=e();return()=>{r.closed||r.unsubscribe()}}),r)}function g(e){const r=m((()=>new s),[],"useStateObservable");t((()=>()=>r.complete()),[]);const n=o((e=>{const n=e;r.next(n)}),[r]),u=m((()=>function(e,r){const n=w(r)?r():r,t=e.pipe(b(n),f(((e,r)=>w(r)?r(e):r)),l(Object.is));return c(t,{connector:()=>new a(1),resetOnDisconnect:!1})}(r,e)),[r],"useStateObservable");return h((()=>u.connect()),[u]),[u,n]}function E(e){if(!u(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useIsComplete`);const r=function(){const[e,r]=n(void 0);if(void 0!==e)throw e;return r}(),[o,s]=n(!1),i=p([e],"useIsComplete");return t((()=>{i&&s(!1)}),[i]),h((()=>e.subscribe({complete(){s(!0)},error(e){r(e)}})),[e]),o}export{O as useEventObservable,E as useIsComplete,y as useObservable,d as useObservableOf,g as useState$,g as useStateObservable,h as useSubscription};
//# sourceMappingURL=index.esm.js.map
