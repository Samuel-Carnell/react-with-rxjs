{"version":3,"file":"index.esm.js","sources":["../src/hooks/internal/use-has-input-changed/use-has-input-changed.ts","../src/hooks/internal/use-factory/use-factory.ts","../src/hooks/use-event-observable/use-event-observable.ts","../src/helpers/is-function/is-function.ts","../src/hooks/use-observable/use-observable.ts","../src/hooks/use-observable-of/use-observable-of.ts","../src/hooks/use-subscription/use-subscription.ts","../src/hooks/use-state-observable/use-state-observable.ts","../src/hooks/use-is-complete/use-is-complete.ts","../src/hooks/internal/use-throw-component-error/use-throw-component-error.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\n\nfunction logError(message: string, ...args: unknown[]) {\n\tconst IS_DEV = process.env.NODE_ENV === 'development';\n\tif (IS_DEV) {\n\t\tconsole.error(message, args);\n\t}\n}\n\nfunction areInputsDifferent<TInput extends any[]>(\n\tprevInputs: TInput,\n\tnextInputs: TInput,\n\trootHookName: string\n) {\n\tif (nextInputs.length !== prevInputs.length) {\n\t\tlogError(\n\t\t\t'The final argument passed to %s changed size between renders. The ' +\n\t\t\t\t'order and size of this array must remain constant.\\n\\n' +\n\t\t\t\t'Previous: %s\\n' +\n\t\t\t\t'Incoming: %s',\n\t\t\trootHookName,\n\t\t\t`[${prevInputs.join(', ')}]`,\n\t\t\t`[${nextInputs.join(', ')}]`\n\t\t);\n\t}\n\n\tfor (let i = 0; i < prevInputs.length && i < nextInputs.length; i++) {\n\t\tif (!Object.is(prevInputs[i], nextInputs[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function useHasInputChanged<TInput extends any[]>(\n\tinput: TInput,\n\trootHookName = 'useHasInputChanged'\n): boolean {\n\tconst inputRef = useRef<TInput>(input);\n\tconst isInputDifferent = areInputsDifferent(inputRef.current, input, rootHookName);\n\n\t// Only update the inputRef once the render has been committed, this is required as react may call this hook without\n\t// committing the changes\n\tuseEffect(() => {\n\t\tinputRef.current = input;\n\t});\n\n\treturn isInputDifferent;\n}\n","import { useEffect, useRef } from 'react';\nimport { useHasInputChanged } from 'hooks/internal/use-has-input-changed';\n\nexport function useFactory<TValue>(\n\tfactory: () => TValue,\n\tdependencies: unknown[],\n\trootHookName = 'useFactory'\n): TValue {\n\tconst valueRef = useRef<TValue | undefined>(undefined);\n\tconst hasDependenciesChanged = useHasInputChanged(dependencies, rootHookName);\n\tconst currentValue =\n\t\tvalueRef.current === undefined || hasDependenciesChanged ? factory() : valueRef.current;\n\n\t// Only update the valueRef once the render has been committed, this is required as react may call this hook without\n\t// committing the changes\n\tuseEffect(() => {\n\t\tvalueRef.current = currentValue;\n\t});\n\n\treturn currentValue;\n}\n","import { useCallback, useLayoutEffect } from 'react';\nimport { Observable, Subject } from 'rxjs';\nimport { useFactory } from 'hooks/internal';\n\ntype Emit<T> = (event: T) => void;\n\n/**\n * Returns an observable of events (`events$`) and a function to emit a new event (`emit`).\n */\nexport function useEventObservable<TEvent>(): [events$: Observable<TEvent>, emit: Emit<TEvent>] {\n\tconst eventSubject: Subject<TEvent> = useFactory(\n\t\t() => new Subject<TEvent>(),\n\t\t[],\n\t\t'useEventObservable'\n\t);\n\n\tuseLayoutEffect(() => {\n\t\treturn () => eventSubject.complete();\n\t}, [eventSubject]);\n\n\tconst emit: Emit<TEvent> = useCallback((event) => eventSubject.next(event), [eventSubject]);\n\n\tconst events$: Observable<TEvent> = useFactory(\n\t\t() => eventSubject.asObservable(),\n\t\t[],\n\t\t'useEventObservable'\n\t);\n\n\treturn [events$, emit];\n}\n","export function isFunction(value: unknown): value is (...args: any[]) => any {\n\treturn typeof value === 'function';\n}\n","import { isObservable, Observable } from 'rxjs';\nimport { useFactory } from 'hooks/internal';\nimport { isFunction } from 'helpers';\n\n/**\n * Uses the provided `observableFactory` to compute the returned observable. This observable persists across renders,\n * only being recomputed if any values in the `dependencies` array change.\n */\nexport function useObservable<TObservable extends Observable<unknown>>(\n\tobservableFactory: () => TObservable,\n\tdependencies: unknown[] = []\n): TObservable {\n\tif (!isFunction(observableFactory)) {\n\t\tthrow new TypeError(\n\t\t\t`${observableFactory} is not a function. For argument observableFactory in useObservable`\n\t\t);\n\t}\n\n\tif (!Array.isArray(dependencies)) {\n\t\tthrow new TypeError(\n\t\t\t`${dependencies} is not an Array. For argument dependencies in useObservable`\n\t\t);\n\t}\n\n\tconst observable: TObservable = useFactory(observableFactory, dependencies, 'useObservable');\n\n\tif (!isObservable(observable)) {\n\t\tthrow new TypeError(\n\t\t\t`${observable} is not an Observable. For return value of argument observableFactory in useObservable`\n\t\t);\n\t}\n\n\treturn observable;\n}\n","import { useEffect } from 'react';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { useFactory, useHasInputChanged } from 'hooks/internal';\n\n/**\n * Returns an observable persisting across renders. Emitting `value` on the initial render, then emitting `value` again\n * if it has changed in between re-renders.\n */\nexport function useObservableOf<TValue>(value: TValue): Observable<TValue> {\n\t// value is not specified as a dependency so the behavior subject is only created on the first render\n\tconst value$: BehaviorSubject<TValue> = useFactory(\n\t\t() => new BehaviorSubject(value),\n\t\t[],\n\t\t'useObservableOf'\n\t);\n\tconst hasValueChanged = useHasInputChanged([value], 'useObservableOf');\n\n\tuseEffect(() => {\n\t\tif (hasValueChanged) {\n\t\t\tvalue$.next(value);\n\t\t}\n\t});\n\n\treturn useFactory(() => value$.asObservable(), [value$], 'useObservableOf');\n}\n","import { isFunction } from 'helpers';\nimport { useLayoutEffect } from 'react';\nimport { SubscriptionLike } from 'rxjs';\n\n/**\n * Establishes a new subscription using the `subscriptionFactory`. This subscription persists across renders, and is\n * destroyed when the component unmounts. Only being re-established if any of the dependencies change, destroying the\n * previous subscription in the process.\n */\nexport function useSubscription(\n\tsubscriptionFactory: () => SubscriptionLike,\n\tdependencies: unknown[]\n): void {\n\tif (!isFunction(subscriptionFactory)) {\n\t\tthrow new TypeError(\n\t\t\t`${subscriptionFactory} is not a function. For argument subscriptionFactory in useSubscription`\n\t\t);\n\t}\n\n\tif (!Array.isArray(dependencies)) {\n\t\tthrow new TypeError(\n\t\t\t`${dependencies} is not an Array. For argument dependencies in useSubscription`\n\t\t);\n\t}\n\n\tuseLayoutEffect(() => {\n\t\tconst subscription = subscriptionFactory();\n\t\treturn () => {\n\t\t\tif (!subscription.closed) {\n\t\t\t\tsubscription.unsubscribe();\n\t\t\t}\n\t\t};\n\t}, dependencies);\n}\n","import { useCallback, useLayoutEffect } from 'react';\nimport { connectable, Connectable, Observable, ReplaySubject, Subject } from 'rxjs';\nimport { distinctUntilChanged, scan, startWith } from 'rxjs/operators';\nimport { useFactory } from 'hooks/internal';\nimport { useSubscription } from 'hooks/use-subscription';\nimport { isFunction } from 'helpers';\n\ntype Factory<T> = () => T;\ntype Operator<T> = (value: T) => T;\n\ntype SetSate<T> = (state: T | Operator<T>) => void;\n\nfunction currentValue$<TValue>(\n\tvalueOrOperatorFn$: Observable<TValue | Operator<TValue>>,\n\tinitialValueOrFactoryFn: TValue | Factory<TValue>\n): Connectable<TValue> {\n\tconst initialValue: TValue = isFunction(initialValueOrFactoryFn)\n\t\t? initialValueOrFactoryFn()\n\t\t: initialValueOrFactoryFn;\n\n\tconst currentValue$: Observable<TValue> = valueOrOperatorFn$.pipe(\n\t\tstartWith(initialValue),\n\t\tscan((previousValue: TValue, valueOrTransform: TValue | Operator<TValue>) => {\n\t\t\treturn isFunction(valueOrTransform) ? valueOrTransform(previousValue) : valueOrTransform;\n\t\t}),\n\t\tdistinctUntilChanged(Object.is)\n\t);\n\n\treturn connectable(currentValue$, {\n\t\tconnector: () => new ReplaySubject(1),\n\t\tresetOnDisconnect: false,\n\t});\n}\n\n/**\n * Returns an observable of the current state (`state$`) and a function to update the current state (`setState`).\n */\nexport function useStateObservable<TState>(): [\n\tstate$: Observable<TState | undefined>,\n\tsetState: SetSate<TState>\n];\n\n/**\n * Returns an observable of the current state (`state$`) and a function to update the current state (`setState`).\n */\nexport function useStateObservable<TState>(\n\tinitialState: TState | Factory<TState>\n): [state$: Observable<TState>, setState: SetSate<TState>];\n\nexport function useStateObservable(\n\tinitialState?: unknown | Factory<unknown>\n): [state$: Observable<unknown>, setState: SetSate<unknown>] {\n\tconst valueOrOperatorFn$: Subject<unknown | Operator<unknown>> = useFactory(\n\t\t() => new Subject<unknown | Operator<unknown>>(),\n\t\t[],\n\t\t'useStateObservable'\n\t);\n\n\tuseLayoutEffect(() => {\n\t\treturn () => valueOrOperatorFn$.complete();\n\t}, []);\n\n\tconst setState: SetSate<unknown> = useCallback(\n\t\t(state: unknown | Operator<unknown>) => {\n\t\t\tconst valueOrOperator = state;\n\t\t\tvalueOrOperatorFn$.next(valueOrOperator);\n\t\t},\n\t\t[valueOrOperatorFn$]\n\t);\n\n\t// initialState is not specified as a dependency as it is only used when the component mounts\n\tconst currentState$: Connectable<unknown> = useFactory(\n\t\t() => currentValue$(valueOrOperatorFn$, initialState),\n\t\t[valueOrOperatorFn$],\n\t\t'useStateObservable'\n\t);\n\n\tuseSubscription(() => currentState$.connect(), [currentState$]);\n\n\treturn [currentState$, setState];\n}\n","import { useHasInputChanged, useThrowComponentError } from 'hooks/internal';\nimport { useSubscription } from 'hooks/use-subscription';\nimport { useLayoutEffect, useState } from 'react';\nimport { isObservable, Observable } from 'rxjs';\n\n/**\n * Subscribes to `source$` and returns true if it has completed, otherwise false.\n */\nexport function useIsComplete(source$: Observable<unknown>): boolean {\n\tif (!isObservable(source$)) {\n\t\tthrow new TypeError(\n\t\t\t`${source$} is not an Observable. For return value of argument observable in useIsComplete`\n\t\t);\n\t}\n\n\tconst throwComponentError = useThrowComponentError();\n\tconst [isComplete, setIsComplete] = useState<boolean>(false);\n\n\tconst hasSource$Changed = useHasInputChanged([source$], 'useIsComplete');\n\tuseLayoutEffect(() => {\n\t\tif (hasSource$Changed) {\n\t\t\tsetIsComplete(false);\n\t\t}\n\t}, [hasSource$Changed]);\n\n\tuseSubscription(() => {\n\t\treturn source$.subscribe({\n\t\t\tcomplete(): void {\n\t\t\t\tsetIsComplete(true);\n\t\t\t},\n\t\t\terror(error: unknown): void {\n\t\t\t\tthrowComponentError(error);\n\t\t\t},\n\t\t});\n\t}, [source$]);\n\n\treturn isComplete;\n}\n","import { useState } from 'react';\n\ntype ThrowComponentError = (error: unknown) => void;\n\nexport function useThrowComponentError(): ThrowComponentError {\n\tconst [error, setError] = useState<unknown | undefined>(undefined);\n\tif (error !== undefined) {\n\t\tthrow error;\n\t}\n\treturn setError;\n}\n"],"names":["areInputsDifferent","prevInputs","nextInputs","rootHookName","length","message","args","process","env","NODE_ENV","console","error","logError","join","i","Object","is","useHasInputChanged","input","inputRef","useRef","isInputDifferent","current","useEffect","useFactory","factory","dependencies","valueRef","undefined","hasDependenciesChanged","currentValue","useEventObservable","eventSubject","Subject","useLayoutEffect","complete","emit","useCallback","event","next","asObservable","isFunction","value","useObservable","observableFactory","TypeError","Array","isArray","observable","isObservable","useObservableOf","value$","BehaviorSubject","hasValueChanged","useSubscription","subscriptionFactory","subscription","closed","unsubscribe","useStateObservable","initialState","valueOrOperatorFn$","setState","state","valueOrOperator","currentState$","initialValueOrFactoryFn","initialValue","currentValue$","pipe","startWith","scan","previousValue","valueOrTransform","distinctUntilChanged","connectable","connector","ReplaySubject","resetOnDisconnect","connect","useIsComplete","source$","throwComponentError","setError","useState","useThrowComponentError","isComplete","setIsComplete","hasSource$Changed","subscribe","[object Object]"],"mappings":"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"}