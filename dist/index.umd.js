!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("rxjs"),require("rxjs/operators")):"function"==typeof define&&define.amd?define(["exports","react","rxjs","rxjs/operators"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["react-with-rxjs"]={},e.react,e.rxjs,e.operators)}(this,(function(e,t,r,n){"use strict";function s(e){if(!(e=>"object"==typeof e&&null!=e&&"Consumer"in e&&"Provider"in e)(e))throw new TypeError(`${e} is not a React Context. For argument context in useContextObservable`);return f(t.useContext(e))}function o(e,t,r){t.length!==e.length&&function(e,...t){"development"===process.env.NODE_ENV&&console.error(e,t)}("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",r,`[${e.join(", ")}]`,`[${t.join(", ")}]`);for(let r=0;r<e.length&&r<t.length;r++)if(!Object.is(e[r],t[r]))return!0;return!1}function u(e,r="useHasInputChanged"){const n=t.useRef(e),s=o(n.current,e,r);return t.useEffect((()=>{n.current=e})),s}function a(e,r,n="useFactory"){const s=t.useRef(void 0),o=u(r,n),a=void 0===s.current||o?e():s.current;return t.useEffect((()=>{s.current=a})),a}function i(){const[e,r]=t.useState(void 0);if(void 0!==e)throw e;return r}function c(){const e=a((()=>new r.Subject),[],"useEventObservable");t.useLayoutEffect((()=>()=>e.complete()),[e]);const n=t.useCallback((t=>e.next(t)),[e]);return[a((()=>e.asObservable()),[],"useEventObservable"),n]}function b(e){return"function"==typeof e}function f(e){const n=a((()=>new r.BehaviorSubject(e)),[],"useObservableOf"),s=u([e],"useObservableOf");return t.useEffect((()=>{s&&n.next(e)})),a((()=>n.asObservable()),[n],"useObservableOf")}function l(e,r){if(!b(e))throw new TypeError(`${e} is not a function. For argument subscriptionFactory in useSubscription`);if(!Array.isArray(r))throw new TypeError(`${r} is not an Array. For argument dependencies in useSubscription`);t.useLayoutEffect((()=>{const t=e();return()=>{t.closed||t.unsubscribe()}}),r)}function v(e){const s=a((()=>new r.Subject),[],"useStateObservable");t.useLayoutEffect((()=>()=>s.complete()),[]);const o=t.useCallback((e=>{const t=e;s.next(t)}),[s]),u=a((()=>function(e,t){const s=b(t)?t():t,o=e.pipe(n.startWith(s),n.scan(((e,t)=>b(t)?t(e):t)),n.distinctUntilChanged(Object.is));return r.connectable(o,{connector:()=>new r.ReplaySubject(1),resetOnDisconnect:!1})}(s,e)),[s],"useStateObservable");return l((()=>u.connect()),[u]),[u,o]}e.useContext$=s,e.useContextObservable=s,e.useEvent$=c,e.useEventObservable=c,e.useIsComplete=function(e){if(!r.isObservable(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useIsComplete`);const n=i(),[s,o]=t.useState(!1),a=u([e],"useIsComplete");return t.useLayoutEffect((()=>{a&&o(!1)}),[a]),l((()=>e.subscribe({complete(){o(!0)},error(e){n(e)}})),[e]),s},e.useLatestValue=function(e){if(!r.isObservable(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useLatestValue`);const n=i(),[s,o]=t.useState((()=>function(e){return"getValue"in e}(e)?e.getValue():void 0));return l((()=>e.subscribe({next(e){o((()=>e))},error(e){n(e)}})),[e]),s},e.useObservable=function(e,t=[]){if(!b(e))throw new TypeError(`${e} is not a function. For argument observableFactory in useObservable`);if(!Array.isArray(t))throw new TypeError(`${t} is not an Array. For argument dependencies in useObservable`);const n=a(e,t,"useObservable");if(!r.isObservable(n))throw new TypeError(`${n} is not an Observable. For return value of argument observableFactory in useObservable`);return n},e.useObservableOf=f,e.useState$=v,e.useStateObservable=v,e.useSubscription=l,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
