!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("rxjs"),require("rxjs/operators")):"function"==typeof define&&define.amd?define(["exports","react","rxjs","rxjs/operators"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["react-with-rxjs"]={},e.react,e.rxjs,e.operators)}(this,(function(e,t,r,n){"use strict";function s(e){if(!(e=>"object"==typeof e&&null!=e&&"Consumer"in e&&"Provider"in e)(e))throw new TypeError(`${e} is not a React Context. For argument context in useContextObservable`);return l(t.useContext(e))}function o(e){return"function"==typeof e}function u(e,t,r){t.length!==e.length&&function(e,...t){"development"===process.env.NODE_ENV&&console.error(e,t)}("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",r,`[${e.join(", ")}]`,`[${t.join(", ")}]`);for(let r=0;r<e.length&&r<t.length;r++)if(!Object.is(e[r],t[r]))return!0;return!1}function a(e,r="useHasInputChanged"){const n=t.useRef(e),s=u(n.current,e,r);return t.useEffect((()=>{n.current=e})),s}function i(e,r,n="useFactory"){const s=t.useRef(void 0),o=a(r,n),u=void 0===s.current||o?e():s.current;return t.useEffect((()=>{s.current=u})),u}function c(){const[e,r]=t.useState(void 0);if(void 0!==e)throw e;return r}function b(e,r){t.useLayoutEffect((()=>{const t=e();return()=>{t.closed||t.unsubscribe()}}),r)}function f(){const e=i((()=>new r.Subject),[],"useEventObservable");t.useLayoutEffect((()=>()=>e.complete()),[e]);const n=t.useCallback((t=>e.next(t)),[e]);return[i((()=>e.asObservable()),[],"useEventObservable"),n]}function l(e){const n=i((()=>new r.BehaviorSubject(e)),[],"useObservableOf"),s=a([e],"useObservableOf");return t.useEffect((()=>{s&&n.next(e)})),i((()=>n.asObservable()),[n],"useObservableOf")}function v(e,t){if(!o(e))throw new TypeError(`${e} is not a function. For argument subscriptionFactory in useSubscription`);if(!Array.isArray(t))throw new TypeError(`${t} is not an Array. For argument dependencies in useSubscription`);b(e,t)}function p(e){const s=i((()=>new r.Subject),[],"useStateObservable");t.useLayoutEffect((()=>()=>s.complete()),[]);const u=t.useCallback((e=>{const t=e;s.next(t)}),[s]),a=i((()=>function(e,t){const s=o(t)?t():t,u=e.pipe(n.startWith(s),n.scan(((e,t)=>o(t)?t(e):t)),n.distinctUntilChanged(Object.is));return r.connectable(u,{connector:()=>new r.ReplaySubject(1),resetOnDisconnect:!1})}(s,e)),[s],"useStateObservable");return v((()=>a.connect()),[a]),[a,u]}e.useContext$=s,e.useContextObservable=s,e.useEvent$=f,e.useEventObservable=f,e.useIsComplete=function(e){if(!r.isObservable(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useIsComplete`);const n=c(),[s,o]=t.useState(!1),u=a([e],"useIsComplete");return t.useLayoutEffect((()=>{u&&o(!1)}),[u]),b((()=>e.subscribe({complete(){o(!0)},error(e){n(e)}})),[e]),s},e.useLatestValue=function(e){if(!r.isObservable(e))throw new TypeError(`${e} is not an Observable. For return value of argument observable in useLatestValue`);const n=c(),[s,o]=t.useState((()=>function(e){return"getValue"in e}(e)?e.getValue():void 0));return b((()=>e.subscribe({next(e){o((()=>e))},error(e){n(e)}})),[e]),s},e.useObservable=function(e,t=[]){if(!o(e))throw new TypeError(`${e} is not a function. For argument observableFactory in useObservable`);if(!Array.isArray(t))throw new TypeError(`${t} is not an Array. For argument dependencies in useObservable`);const n=i(e,t,"useObservable");if(!r.isObservable(n))throw new TypeError(`${n} is not an Observable. For return value of argument observableFactory in useObservable`);return n},e.useObservableOf=l,e.useState$=p,e.useStateObservable=p,e.useSubscription=v,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
