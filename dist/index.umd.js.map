{"version":3,"file":"index.umd.js","sources":["../src/hooks/use-context-observable/use-context-observable.ts","../src/hooks/internal/use-has-input-changed/use-has-input-changed.ts","../src/hooks/internal/use-factory/use-factory.ts","../src/hooks/internal/use-throw-component-error/use-throw-component-error.ts","../src/hooks/use-event-observable/use-event-observable.ts","../src/helpers/is-function/is-function.ts","../src/hooks/use-observable-of/use-observable-of.ts","../src/hooks/use-subscription/use-subscription.ts","../src/hooks/use-state-observable/use-state-observable.ts","../src/hooks/use-is-complete/use-is-complete.ts","../src/hooks/use-latest-value/use-latest-value.ts","../src/hooks/use-observable/use-observable.ts"],"sourcesContent":["import { useObservableOf } from 'hooks';\nimport { useContext, Context } from 'react';\nimport { Observable } from 'rxjs';\n\nconst isContext = <T>(context: unknown): context is Context<T> => {\n\treturn (\n\t\ttypeof context === 'object' && context != null && 'Consumer' in context && 'Provider' in context\n\t);\n};\n\n/**\n * Returns an observable of the current value for the given context .\n */\nexport function useContextObservable<T>(context: Context<T>): Observable<T> {\n\tif (!isContext<T>(context)) {\n\t\tthrow new TypeError(\n\t\t\t`${context} is not a React Context. For argument context in useContextObservable`\n\t\t);\n\t}\n\n\tconst value: T = useContext(context);\n\treturn useObservableOf(value);\n}\n","import { useEffect, useRef } from 'react';\n\nfunction logError(message: string, ...args: unknown[]) {\n\tconst IS_DEV = process.env.NODE_ENV === 'development';\n\tif (IS_DEV) {\n\t\tconsole.error(message, args);\n\t}\n}\n\nfunction areInputsDifferent<TInput extends any[]>(\n\tprevInputs: TInput,\n\tnextInputs: TInput,\n\trootHookName: string\n) {\n\tif (nextInputs.length !== prevInputs.length) {\n\t\tlogError(\n\t\t\t'The final argument passed to %s changed size between renders. The ' +\n\t\t\t\t'order and size of this array must remain constant.\\n\\n' +\n\t\t\t\t'Previous: %s\\n' +\n\t\t\t\t'Incoming: %s',\n\t\t\trootHookName,\n\t\t\t`[${prevInputs.join(', ')}]`,\n\t\t\t`[${nextInputs.join(', ')}]`\n\t\t);\n\t}\n\n\tfor (let i = 0; i < prevInputs.length && i < nextInputs.length; i++) {\n\t\tif (!Object.is(prevInputs[i], nextInputs[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function useHasInputChanged<TInput extends any[]>(\n\tinput: TInput,\n\trootHookName = 'useHasInputChanged'\n): boolean {\n\tconst inputRef = useRef<TInput>(input);\n\tconst isInputDifferent = areInputsDifferent(inputRef.current, input, rootHookName);\n\n\t// Only update the inputRef once the render has been committed, this is required as react may call this hook without\n\t// committing the changes\n\tuseEffect(() => {\n\t\tinputRef.current = input;\n\t});\n\n\treturn isInputDifferent;\n}\n","import { useEffect, useRef } from 'react';\nimport { useHasInputChanged } from 'hooks/internal/use-has-input-changed';\n\nexport function useFactory<TValue>(\n\tfactory: () => TValue,\n\tdependencies: unknown[],\n\trootHookName = 'useFactory'\n): TValue {\n\tconst valueRef = useRef<TValue | undefined>(undefined);\n\tconst hasDependenciesChanged = useHasInputChanged(dependencies, rootHookName);\n\tconst currentValue =\n\t\tvalueRef.current === undefined || hasDependenciesChanged ? factory() : valueRef.current;\n\n\t// Only update the valueRef once the render has been committed, this is required as react may call this hook without\n\t// committing the changes\n\tuseEffect(() => {\n\t\tvalueRef.current = currentValue;\n\t});\n\n\treturn currentValue;\n}\n","import { useState } from 'react';\n\ntype ThrowComponentError = (error: unknown) => void;\n\nexport function useThrowComponentError(): ThrowComponentError {\n\tconst [error, setError] = useState<unknown | undefined>(undefined);\n\tif (error !== undefined) {\n\t\tthrow error;\n\t}\n\treturn setError;\n}\n","import { useCallback, useLayoutEffect } from 'react';\nimport { Observable, Subject } from 'rxjs';\nimport { useFactory } from 'hooks/internal';\n\ntype Emit<T> = (event: T) => void;\n\n/**\n * Returns an observable of events and a function to emit a new event.\n */\nexport function useEventObservable<TEvent>(): [events$: Observable<TEvent>, emit: Emit<TEvent>] {\n\tconst eventSubject: Subject<TEvent> = useFactory(\n\t\t() => new Subject<TEvent>(),\n\t\t[],\n\t\t'useEventObservable'\n\t);\n\n\tuseLayoutEffect(() => {\n\t\treturn () => eventSubject.complete();\n\t}, [eventSubject]);\n\n\tconst emit: Emit<TEvent> = useCallback((event) => eventSubject.next(event), [eventSubject]);\n\n\tconst events$: Observable<TEvent> = useFactory(\n\t\t() => eventSubject.asObservable(),\n\t\t[],\n\t\t'useEventObservable'\n\t);\n\n\treturn [events$, emit];\n}\n","export function isFunction(value: unknown): value is (...args: any[]) => any {\n\treturn typeof value === 'function';\n}\n","import { useEffect } from 'react';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { useFactory, useHasInputChanged } from 'hooks/internal';\n\n/**\n * Returns an observable of distinct values passed, with this hook checking if the value has changed on each render.\n */\nexport function useObservableOf<TValue>(value: TValue): Observable<TValue> {\n\t// value is not specified as a dependency so the behavior subject is only created on the first render\n\tconst value$: BehaviorSubject<TValue> = useFactory(\n\t\t() => new BehaviorSubject(value),\n\t\t[],\n\t\t'useObservableOf'\n\t);\n\tconst hasValueChanged = useHasInputChanged([value], 'useObservableOf');\n\n\tuseEffect(() => {\n\t\tif (hasValueChanged) {\n\t\t\tvalue$.next(value);\n\t\t}\n\t});\n\n\treturn useFactory(() => value$.asObservable(), [value$], 'useObservableOf');\n}\n","import { isFunction } from 'helpers';\nimport { useLayoutEffect } from 'react';\nimport { SubscriptionLike } from 'rxjs';\n\n/**\n * Establishes a new subscription using the given `subscriptionFactory`. This subscription persists across renders, and\n * is destroyed when the component unmounts. If any of the dependencies change between render, the previous subscription\n * will be destroy and a new subscription established using the `subscriptionFactory`.\n */\nexport function useSubscription(\n\tsubscriptionFactory: () => SubscriptionLike,\n\tdependencies: unknown[]\n): void {\n\tif (!isFunction(subscriptionFactory)) {\n\t\tthrow new TypeError(\n\t\t\t`${subscriptionFactory} is not a function. For argument subscriptionFactory in useSubscription`\n\t\t);\n\t}\n\n\tif (!Array.isArray(dependencies)) {\n\t\tthrow new TypeError(\n\t\t\t`${dependencies} is not an Array. For argument dependencies in useSubscription`\n\t\t);\n\t}\n\n\tuseLayoutEffect(() => {\n\t\tconst subscription = subscriptionFactory();\n\t\treturn () => {\n\t\t\tif (!subscription.closed) {\n\t\t\t\tsubscription.unsubscribe();\n\t\t\t}\n\t\t};\n\t}, dependencies);\n}\n","import { useCallback, useLayoutEffect } from 'react';\nimport { connectable, Connectable, Observable, ReplaySubject, Subject } from 'rxjs';\nimport { distinctUntilChanged, scan, startWith } from 'rxjs/operators';\nimport { useFactory } from 'hooks/internal';\nimport { useSubscription } from 'hooks/use-subscription';\nimport { isFunction } from 'helpers';\n\ntype Factory<T> = () => T;\ntype Operator<T> = (value: T) => T;\n\ntype SetSate<T> = (state: T | Operator<T>) => void;\n\nfunction currentValue$<TValue>(\n\tvalueOrOperatorFn$: Observable<TValue | Operator<TValue>>,\n\tinitialValueOrFactoryFn: TValue | Factory<TValue>\n): Connectable<TValue> {\n\tconst initialValue: TValue = isFunction(initialValueOrFactoryFn)\n\t\t? initialValueOrFactoryFn()\n\t\t: initialValueOrFactoryFn;\n\n\tconst currentValue$: Observable<TValue> = valueOrOperatorFn$.pipe(\n\t\tstartWith(initialValue),\n\t\tscan((previousValue: TValue, valueOrTransform: TValue | Operator<TValue>) => {\n\t\t\treturn isFunction(valueOrTransform) ? valueOrTransform(previousValue) : valueOrTransform;\n\t\t}),\n\t\tdistinctUntilChanged(Object.is)\n\t);\n\n\treturn connectable(currentValue$, {\n\t\tconnector: () => new ReplaySubject(1),\n\t\tresetOnDisconnect: false,\n\t});\n}\n\n/**\n * Returns an observable of the current state (`state$`) and a function to update the current state (`setState`).\n */\nexport function useStateObservable<TState>(): [\n\tstate$: Observable<TState | undefined>,\n\tsetState: SetSate<TState>\n];\n\n/**\n * Returns an observable of the current state and a function to update the current state.\n */\nexport function useStateObservable<TState>(\n\tinitialState: TState | Factory<TState>\n): [state$: Observable<TState>, setState: SetSate<TState>];\n\nexport function useStateObservable(\n\tinitialState?: unknown | Factory<unknown>\n): [state$: Observable<unknown>, setState: SetSate<unknown>] {\n\tconst valueOrOperatorFn$: Subject<unknown | Operator<unknown>> = useFactory(\n\t\t() => new Subject<unknown | Operator<unknown>>(),\n\t\t[],\n\t\t'useStateObservable'\n\t);\n\n\tuseLayoutEffect(() => {\n\t\treturn () => valueOrOperatorFn$.complete();\n\t}, []);\n\n\tconst setState: SetSate<unknown> = useCallback(\n\t\t(state: unknown | Operator<unknown>) => {\n\t\t\tconst valueOrOperator = state;\n\t\t\tvalueOrOperatorFn$.next(valueOrOperator);\n\t\t},\n\t\t[valueOrOperatorFn$]\n\t);\n\n\t// initialState is not specified as a dependency as it is only used when the component mounts\n\tconst currentState$: Connectable<unknown> = useFactory(\n\t\t() => currentValue$(valueOrOperatorFn$, initialState),\n\t\t[valueOrOperatorFn$],\n\t\t'useStateObservable'\n\t);\n\n\tuseSubscription(() => currentState$.connect(), [currentState$]);\n\n\treturn [currentState$, setState];\n}\n","import { useHasInputChanged, useThrowComponentError } from 'hooks/internal';\nimport { useSubscription } from 'hooks/use-subscription';\nimport { useLayoutEffect, useState } from 'react';\nimport { isObservable, Observable } from 'rxjs';\n\n/**\n * Subscribes to the given observable and returns `true` if its complete, otherwise `false` until it does complete. If\n * the observable changes between renders this hook will unsubscribe from the previous observable and subscribe to the\n * new observable, returning its current completed state.\n */\nexport function useIsComplete(source$: Observable<unknown>): boolean {\n\tif (!isObservable(source$)) {\n\t\tthrow new TypeError(\n\t\t\t`${source$} is not an Observable. For return value of argument observable in useIsComplete`\n\t\t);\n\t}\n\n\tconst throwComponentError = useThrowComponentError();\n\tconst [isComplete, setIsComplete] = useState<boolean>(false);\n\n\tconst hasSource$Changed = useHasInputChanged([source$], 'useIsComplete');\n\tuseLayoutEffect(() => {\n\t\tif (hasSource$Changed) {\n\t\t\tsetIsComplete(false);\n\t\t}\n\t}, [hasSource$Changed]);\n\n\tuseSubscription(() => {\n\t\treturn source$.subscribe({\n\t\t\tcomplete(): void {\n\t\t\t\tsetIsComplete(true);\n\t\t\t},\n\t\t\terror(error: unknown): void {\n\t\t\t\tthrowComponentError(error);\n\t\t\t},\n\t\t});\n\t}, [source$]);\n\n\treturn isComplete;\n}\n","import { useThrowComponentError } from 'hooks/internal';\nimport { useSubscription } from 'hooks/use-subscription';\nimport { useState } from 'react';\nimport { BehaviorSubject, isObservable, Observable } from 'rxjs';\n\nfunction isBehaviorSubject(source$: Observable<unknown>): source$ is BehaviorSubject<unknown> {\n\treturn 'getValue' in source$;\n}\n\n/**\n * Subscribes to the given observable, returning the latest emitted value and re-rendering the component when it emits a\n * new value. If the observable changes between renders this hook will unsubscribe from the previous observable and\n * subscribe to the new observable, but will return the last emitted value from the previous observable until the new\n * observable emits a new value.\n */\nexport function useLatestValue<TValue>(source$: BehaviorSubject<TValue>): TValue;\n\n/**\n * Subscribes to the given observable, returning the latest emitted value and re-rendering the component when it emits a\n * new value. If the observable changes between renders this hook will unsubscribe from the previous observable and\n * subscribe to the new observable, but will return the last emitted value from the previous observable until the new\n * observable emits a new value.\n */\nexport function useLatestValue<TValue>(source$: Observable<TValue>): TValue | undefined;\n\nexport function useLatestValue(source$: Observable<unknown>): unknown {\n\tif (!isObservable(source$)) {\n\t\tthrow new TypeError(\n\t\t\t`${source$} is not an Observable. For return value of argument observable in useLatestValue`\n\t\t);\n\t}\n\n\tconst throwComponentError = useThrowComponentError();\n\tconst [latestValue, setLatestValue] = useState(() => {\n\t\treturn isBehaviorSubject(source$) ? source$.getValue() : undefined;\n\t});\n\n\tuseSubscription(() => {\n\t\treturn source$.subscribe({\n\t\t\tnext(value: unknown): void {\n\t\t\t\tsetLatestValue(() => value);\n\t\t\t},\n\t\t\terror(error: unknown): void {\n\t\t\t\tthrowComponentError(error);\n\t\t\t},\n\t\t});\n\t}, [source$]);\n\n\treturn latestValue;\n}\n","import { isObservable, Observable } from 'rxjs';\nimport { useFactory } from 'hooks/internal';\nimport { isFunction } from 'helpers';\n\n/**\n * Uses the provided `observableFactory` to compute the returned observable. This observable persists across renders,\n * only being recomputed if any values in the `dependencies` array change.\n */\nexport function useObservable<TObservable extends Observable<unknown>>(\n\tobservableFactory: () => TObservable,\n\tdependencies: unknown[] = []\n): TObservable {\n\tif (!isFunction(observableFactory)) {\n\t\tthrow new TypeError(\n\t\t\t`${observableFactory} is not a function. For argument observableFactory in useObservable`\n\t\t);\n\t}\n\n\tif (!Array.isArray(dependencies)) {\n\t\tthrow new TypeError(\n\t\t\t`${dependencies} is not an Array. For argument dependencies in useObservable`\n\t\t);\n\t}\n\n\tconst observable: TObservable = useFactory(observableFactory, dependencies, 'useObservable');\n\n\tif (!isObservable(observable)) {\n\t\tthrow new TypeError(\n\t\t\t`${observable} is not an Observable. For return value of argument observableFactory in useObservable`\n\t\t);\n\t}\n\n\treturn observable;\n}\n"],"names":["useContextObservable","context","isContext","TypeError","useObservableOf","useContext","areInputsDifferent","prevInputs","nextInputs","rootHookName","length","message","args","process","env","NODE_ENV","console","error","logError","join","i","Object","is","useHasInputChanged","input","inputRef","useRef","isInputDifferent","current","useEffect","useFactory","factory","dependencies","valueRef","undefined","hasDependenciesChanged","currentValue","useThrowComponentError","setError","useState","useEventObservable","eventSubject","Subject","useLayoutEffect","complete","emit","useCallback","event","next","asObservable","isFunction","value","value$","BehaviorSubject","hasValueChanged","useSubscription","subscriptionFactory","Array","isArray","subscription","closed","unsubscribe","useStateObservable","initialState","valueOrOperatorFn$","setState","state","valueOrOperator","currentState$","initialValueOrFactoryFn","initialValue","currentValue$","pipe","startWith","scan","previousValue","valueOrTransform","distinctUntilChanged","connectable","connector","ReplaySubject","resetOnDisconnect","connect","source$","isObservable","throwComponentError","isComplete","setIsComplete","hasSource$Changed","subscribe","[object Object]","latestValue","setLatestValue","isBehaviorSubject","getValue","observableFactory","observable"],"mappings":"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"}