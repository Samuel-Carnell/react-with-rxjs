{"version":3,"file":"index.umd.js","sources":["../src/internal/map.ts","../src/internal/use-smart-update.ts","../src/internal/mutable-state.ts","../src/internal/use-watch-observable.ts","../src/internal/use-register-subscription.ts","../src/bind.ts","../src/internal/use-as-observables.ts","../src/internal/is-object.ts"],"sourcesContent":["function mapObject(obj: {}, mapValue: (value: unknown) => unknown): {} {\n\tconst keyValuePairs: Array<[string, unknown]> = Object.keys(obj).map(\n\t\t(key) => [key, obj[key]]\n\t);\n\treturn keyValuePairs.reduce((acc, [key, value]) => {\n\t\tacc[key] = mapValue(value);\n\t\treturn acc;\n\t}, {});\n}\n\nfunction mapArray(\n\tarr: unknown[],\n\tmapValue: (value: unknown) => unknown\n): unknown[] {\n\treturn arr.map(mapValue);\n}\n\nfunction map(\n\tmappable: unknown[] | {},\n\tmapValue: (value: unknown) => unknown\n): unknown[] | {} {\n\treturn Array.isArray(mappable)\n\t\t? mapArray(mappable, mapValue)\n\t\t: mapObject(mappable, mapValue);\n}\n\nexport { map };\n","import { useCallback, useRef, useState } from 'react';\nimport { asapScheduler } from 'rxjs';\n\nfunction useForceUpdate(): () => void {\n\tconst [, dispatch] = useState<{}>(Object.create(null));\n\n\tconst forceUpdate = useCallback((): void => {\n\t\tdispatch(Object.create(null));\n\t}, [dispatch]);\n\treturn forceUpdate;\n}\n\nfunction useSmartUpdate(): [() => void, () => void] {\n\tconst scheduledUpdateRef = useRef<undefined | (() => void)>();\n\tconst forceUpdate = useForceUpdate();\n\n\tconst scheduleUpdate = useCallback((): void => {\n\t\tif (scheduledUpdateRef.current !== undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tscheduledUpdateRef.current = forceUpdate;\n\t\tasapScheduler.schedule(() => {\n\t\t\tif (scheduledUpdateRef.current !== undefined) {\n\t\t\t\tscheduledUpdateRef.current();\n\t\t\t\tscheduledUpdateRef.current = undefined;\n\t\t\t}\n\t\t});\n\t}, []);\n\n\tconst descheduleUpdate = useCallback((): void => {\n\t\tscheduledUpdateRef.current = undefined;\n\t}, []);\n\n\treturn [scheduleUpdate, descheduleUpdate];\n}\n\nexport { useSmartUpdate };\n","class MutableValue<T> {\n\tconstructor(private _value: T) {}\n\n\tpublic setState(value: T): void {\n\t\tthis._value = value;\n\t}\n\n\tpublic getCurrentState(): T {\n\t\treturn this._value;\n\t}\n}\n\nexport { MutableValue };\n","import { useCallback, useLayoutEffect } from 'react';\nimport { Observable } from 'rxjs';\nimport { MutableValue as MutableState } from './mutable-state';\nimport { useRegisterSubscription } from './use-register-subscription';\nimport { useSmartUpdate } from './use-smart-update';\n\ntype WatchObservable<T> = (observable: Observable<T>) => MutableState<T>;\n\ntype WatchedState = {\n\terror?: unknown;\n\tvalue?: unknown;\n};\n\nfunction useWatchObservable(): WatchObservable<unknown> {\n\tconst registerSubscription = useRegisterSubscription();\n\tconst [scheduleUpdate, descheduleUpdate] = useSmartUpdate();\n\n\tuseLayoutEffect(() => {\n\t\t// Updates are only scheduled because an observable has emitted a new value\n\t\t// that needs to be read. However if a re render occurs for any other reason\n\t\t// the new value will be read during that render anyway, negating the need\n\t\t// for the scheduled update. Thus it can be descheduled.\n\t\t// This also ensures that any updates will be descheduled if the component were to\n\t\t// unmount.\n\t\treturn descheduleUpdate;\n\t});\n\n\treturn useCallback(($) => {\n\t\tlet isSync = true;\n\t\tconst mutableValue = new MutableState<WatchedState>({});\n\n\t\tregisterSubscription(\n\t\t\t$.subscribe({\n\t\t\t\terror(error) {\n\t\t\t\t\tmutableValue.setState({ error });\n\t\t\t\t\tif (!isSync) {\n\t\t\t\t\t\tscheduleUpdate();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnext(value) {\n\t\t\t\t\tmutableValue.setState({\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t});\n\t\t\t\t\tif (!isSync) {\n\t\t\t\t\t\tscheduleUpdate();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\t\t);\n\n\t\tisSync = false;\n\t\treturn mutableValue;\n\t}, []);\n}\n\nexport { useWatchObservable };\nexport type { WatchedState };\n","import { useCallback, useEffect, useRef } from 'react';\nimport { Subscription } from 'rxjs';\n\nfunction useRegisterSubscription(): (subscription: Subscription) => void {\n\tconst subscriptionsRef = useRef<Subscription[]>([]);\n\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tsubscriptionsRef.current.forEach((x) => {\n\t\t\t\tif (!x.closed) {\n\t\t\t\t\tx.unsubscribe();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}, []);\n\n\treturn useCallback((subscription: Subscription): void => {\n\t\tsubscriptionsRef.current.push(subscription);\n\t}, []);\n}\n\nexport { useRegisterSubscription };\n","import { useState } from 'react';\nimport { isObservable, Observable } from 'rxjs';\nimport { UseState } from 'types';\nimport {\n\tisObject,\n\tmap,\n\tMutableValue,\n\tuseAsObservables,\n\tuseWatchObservable,\n\tWatchedState,\n} from 'internal';\n\nfunction bind<T extends {} | unknown[] | [], P extends Observable<unknown>[]>(\n\tgetState: (...params: P) => T\n): UseState<T, P> {\n\tfunction hook(...inputs: P) {\n\t\tconst watchObservable = useWatchObservable();\n\t\tconst input$s = useAsObservables(inputs);\n\n\t\tconst [state] = useState(() => {\n\t\t\tconst stateModel: T = getState(...(input$s as P));\n\t\t\tif (!(Array.isArray(stateModel) || isObject(stateModel))) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Function getState must return either an object or array.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn map(\n\t\t\t\tstateModel,\n\t\t\t\t(value: unknown): MutableValue<WatchedState> | unknown => {\n\t\t\t\t\treturn isObservable(value) ? watchObservable(value) : value;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\treturn map(\n\t\t\tstate,\n\t\t\t(value: MutableValue<WatchedState> | unknown): unknown => {\n\t\t\t\tif (!(value instanceof MutableValue)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tconst state: WatchedState = value.getCurrentState();\n\t\t\t\tif (state.error !== undefined) {\n\t\t\t\t\tthrow state.error;\n\t\t\t\t}\n\n\t\t\t\treturn state.value;\n\t\t\t}\n\t\t);\n\t}\n\n\treturn hook as UseState<T, P>;\n}\n\nexport { bind };\n","import { useEffect, useState } from 'react';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\n// In strict mode components are rendered twice. For this reason the input observables MUST\n// emit any new values as an effect to ensure they're only emitted once.\nfunction useAsObservables(inputs: unknown[]): Observable<unknown>[] {\n\tconst [input$s] = useState(() => {\n\t\treturn inputs.map((x) => new BehaviorSubject(x));\n\t});\n\n\tuseEffect(() => {\n\t\tinput$s.forEach(($, ind) => {\n\t\t\tconst value = inputs[ind];\n\t\t\tif (!Object.is(value, $.getValue())) {\n\t\t\t\t$.next(value);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn input$s;\n}\n\nexport { useAsObservables };\n","function isObject(value: unknown): value is {} {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\tObject.getPrototypeOf(value).constructor === Object\n\t);\n}\n\nexport { isObject };\n"],"names":["map","mappable","mapValue","Array","isArray","arr","mapArray","obj","Object","keys","key","reduce","acc","value","mapObject","useSmartUpdate","scheduledUpdateRef","useRef","forceUpdate","dispatch","useState","create","useCallback","useForceUpdate","undefined","current","asapScheduler","schedule","MutableValue","[object Object]","_value","this","useWatchObservable","registerSubscription","subscriptionsRef","useEffect","forEach","x","closed","unsubscribe","subscription","push","useRegisterSubscription","scheduleUpdate","descheduleUpdate","useLayoutEffect","$","isSync","mutableValue","MutableState","subscribe","error","setState","bind","getState","inputs","watchObservable","input$s","BehaviorSubject","ind","is","getValue","next","useAsObservables","state","stateModel","getPrototypeOf","constructor","Error","isObservable","getCurrentState"],"mappings":"6TAiBA,SAASA,EACRC,EACAC,GAEA,OAAOC,MAAMC,QAAQH,GAXtB,SACCI,EACAH,GAEA,OAAOG,EAAIL,IAAIE,GAQZI,CAASL,EAAUC,GAtBvB,SAAmBK,EAASL,GAI3B,OAHgDM,OAAOC,KAAKF,GAAKP,KAC/DU,GAAQ,CAACA,EAAKH,EAAIG,MAECC,QAAO,CAACC,GAAMF,EAAKG,MACvCD,EAAIF,GAAOR,EAASW,GACbD,IACL,IAgBAE,CAAUb,EAAUC,GCXxB,SAASa,IACR,MAAMC,EAAqBC,WACrBC,EAXP,WACC,OAASC,GAAYC,WAAaZ,OAAOa,OAAO,OAKhD,OAHoBC,eAAY,KAC/BH,EAASX,OAAOa,OAAO,SACrB,CAACF,IAMgBI,GAoBpB,MAAO,CAlBgBD,eAAY,UACCE,IAA/BR,EAAmBS,UAIvBT,EAAmBS,QAAUP,EAC7BQ,gBAAcC,UAAS,UACaH,IAA/BR,EAAmBS,UACtBT,EAAmBS,UACnBT,EAAmBS,aAAUD,SAG7B,IAEsBF,eAAY,KACpCN,EAAmBS,aAAUD,IAC3B,KChCJ,MAAMI,EACLC,YAAoBC,GAAAC,YAAAD,EAEbD,SAAShB,GACfkB,KAAKD,OAASjB,EAGRgB,kBACN,OAAOE,KAAKD,QCKd,SAASE,IACR,MAAMC,ECXP,WACC,MAAMC,EAAmBjB,SAAuB,IAYhD,OAVAkB,aAAU,IACF,KACND,EAAiBT,QAAQW,SAASC,IAC5BA,EAAEC,QACND,EAAEE,mBAIH,IAEIjB,eAAakB,IACnBN,EAAiBT,QAAQgB,KAAKD,KAC5B,IDJ0BE,IACtBC,EAAgBC,GAAoB7B,IAY3C,OAVA8B,mBAAgB,IAORD,IAGDtB,eAAawB,IACnB,IAAIC,GAAS,EACb,MAAMC,EAAe,IAAIC,EAA2B,IAsBpD,OApBAhB,EACCa,EAAEI,UAAU,CACXrB,MAAMsB,GACLH,EAAaI,SAAS,CAAED,MAAAA,IACnBJ,GACJJ,KAGFd,KAAKhB,GACJmC,EAAaI,SAAS,CACrBvC,MAAAA,IAEIkC,GACJJ,QAMJI,GAAS,EACFC,IACL,IExCJ,SAASK,EACRC,GAuCA,OArCA,YAAiBC,GAChB,MAAMC,EAAkBxB,IAClByB,ECZR,SAA0BF,GACzB,MAAOE,GAAWrC,YAAS,IACnBmC,EAAOvD,KAAKqC,GAAM,IAAIqB,kBAAgBrB,OAY9C,OATAF,aAAU,KACTsB,EAAQrB,SAAQ,CAACU,EAAGa,KACnB,MAAM9C,EAAQ0C,EAAOI,GAChBnD,OAAOoD,GAAG/C,EAAOiC,EAAEe,aACvBf,EAAEgB,KAAKjD,SAKH4C,EDFUM,CAAiBR,IAE1BS,GAAS5C,YAAS,KACxB,MAAM6C,EAAgBX,KAAaG,GACnC,IAAMtD,MAAMC,QAAQ6D,KEnBJ,iBAFDpD,EFqB6BoD,IElBnC,OAAVpD,GACAL,OAAO0D,eAAerD,GAAOsD,cAAgB3D,QFkB3C,MAAM,IAAI4D,MACT,4DEvBL,IAAkBvD,EF2Bf,OAAOb,EACNiE,GACCpD,GACOwD,eAAaxD,GAAS2C,EAAgB3C,GAASA,OAKzD,OAAOb,EACNgE,GACCnD,IACA,KAAMA,aAAiBe,GACtB,OAAOf,EAGR,MAAMmD,EAAsBnD,EAAMyD,kBAClC,QAAoB9C,IAAhBwC,EAAMb,MACT,MAAMa,EAAMb,MAGb,OAAOa,EAAMnD"}